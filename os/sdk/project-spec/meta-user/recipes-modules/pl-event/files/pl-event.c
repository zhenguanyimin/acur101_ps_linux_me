/*  pl-event.c - The simplest kernel module.

* Copyright (C) sykfend, Inc
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.

*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License along
*   with this program. If not, see <http://www.gnu.org/licenses/>.

*/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>
#include <linux/miscdevice.h>
#include <linux/poll.h>

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("skyfend Inc.");
MODULE_DESCRIPTION
    ("pl-event - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "pl-event"
#define PL_EVENT_MINOR (MINORBITS)

struct pl_event_local {
	int irq;
	unsigned long irq_cnt;
	atomic_t irq_in;

	struct miscdevice misc_dev;

	wait_queue_head_t wait_queue_head;
	struct semaphore opened;
};

static irqreturn_t pl_event_irq(int irq, void *lp)
{
	struct pl_event_local *pl_event = (struct pl_event_local *)lp;
	
	//printk("pl-event interrupt\n");
	pl_event->irq_cnt++;
	atomic_set(&pl_event->irq_in, 1);

	wake_up_interruptible(&pl_event->wait_queue_head);
	return IRQ_HANDLED;
}

static int pl_event_open (struct inode *node, struct file *file)
{
	int ret;
	struct miscdevice *mdev	= (struct miscdevice *)file->private_data;
	struct pl_event_local *pl_event = container_of(mdev, struct pl_event_local, misc_dev);

	ret = down_interruptible(&pl_event->opened);
	if (ret < 0)
	{
		return -1;
	}
	
	return 0;
}

static int pl_event_close(struct inode *node, struct file *file)
{
	struct miscdevice *mdev	= (struct miscdevice *)file->private_data;
	struct pl_event_local *pl_event = container_of(mdev, struct pl_event_local, misc_dev);
	
	up(&pl_event->opened);
	return 0;
}

static __poll_t pl_event_poll (struct file *file, struct poll_table_struct *wait)
{	
	struct miscdevice *mdev	= (struct miscdevice *)file->private_data;
	struct pl_event_local *pl_event = container_of(mdev, struct pl_event_local, misc_dev);
	
	__poll_t mask = 0;

	//printk("%s[%d]in\n", __func__, __LINE__);

	poll_wait(file, &pl_event->wait_queue_head, wait);
	if (atomic_read(&pl_event->irq_in))
	{
		atomic_set(&pl_event->irq_in, 0);
		mask |= EPOLLIN;
	}

	//printk("%s[%d]out\n", __func__, __LINE__);

	return mask;
}

static const struct file_operations ops =
{
	.owner = THIS_MODULE,
	.open = pl_event_open,
	.poll = pl_event_poll,
	.release = pl_event_close,
};

static ssize_t irq_cnt_show(struct device *dev, 
							struct device_attribute *attr, char *buf)
{
	struct pl_event_local *pl = dev_get_drvdata(dev);
	unsigned long cnt = pl->irq_cnt;
	
	sprintf(buf, "%u", cnt);
	return strlen(buf);
}

static DEVICE_ATTR_RO(irq_cnt);

static struct attribute *pl_event_attrs[] = 
{
	&dev_attr_irq_cnt.attr,
	NULL,
};

static const struct attribute_group pl_event_attr_group = {
	.attrs = pl_event_attrs,
};
	
static int pl_event_probe(struct platform_device *pdev)
{
	struct resource *r_irq; /* Interrupt resources */
	struct device *dev = &pdev->dev;
	struct pl_event_local *lp = NULL;
	char dev_name[64];

	int rc = 0;
	dev_info(dev, "Device Tree Probing\n");
	
	/* Get iospace for the device */
	lp = (struct pl_event_local *) kzalloc(sizeof(struct pl_event_local), GFP_KERNEL);
	if (!lp) {
		dev_err(dev, "Cound not allocate pl-event device\n");
		return -ENOMEM;
	}
	dev_set_drvdata(dev, lp);

	/* Get IRQ for the device */
	r_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
	if (!r_irq) {
		dev_info(dev, "no IRQ found\n");
		goto error1;
	}
	lp->irq = r_irq->start;
	rc = request_irq(lp->irq, &pl_event_irq, 0, DRIVER_NAME, lp);
	if (rc) {
		dev_err(dev, "Could not allocate interrupt %d.\n",
			lp->irq);
		goto error1;
	}

	sema_init(&lp->opened, 1);
	init_waitqueue_head(&lp->wait_queue_head);

	dev_info(dev, "node name:%s\n", of_node_full_name(dev->of_node));
	sprintf(dev_name, "PL-%s", of_node_full_name(dev->of_node));

	lp->misc_dev.fops = &ops;
	lp->misc_dev.minor = MISC_DYNAMIC_MINOR;
	lp->misc_dev.name = dev_name;
	rc = misc_register(&lp->misc_dev);
	if (rc < 0)
	{
		dev_err(dev, "misc register error:%d\n", rc);
		goto error2;
	}
	
	lp->irq_cnt = 0;
	atomic_set(&lp->irq_in, 0);

	rc = sysfs_create_group(&pdev->dev.kobj, &pl_event_attr_group);
	if (rc < 0)
	{
		dev_err(dev, "create sysfs group error:%d\n", rc);
		goto error3;
	}

	dev_info(dev,"pl-event at irq=%d\n", lp->irq);
	return 0;


error3:
	misc_deregister(&lp->misc_dev);
error2:
	free_irq(lp->irq, lp);
error1:
	kfree(lp);
	dev_set_drvdata(dev, NULL);
	return rc;
}

static int pl_event_remove(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct pl_event_local *lp = dev_get_drvdata(dev);

	sysfs_remove_group(&dev->kobj, &pl_event_attr_group);
	misc_deregister(&lp->misc_dev);
	free_irq(lp->irq, lp);
	kfree(lp);
	dev_set_drvdata(dev, NULL);
	return 0;
}

#ifdef CONFIG_OF
static struct of_device_id pl_event_of_match[] = {
	{ .compatible = "skyfend,pl-event", },
	{ /* end of list */ },
};
MODULE_DEVICE_TABLE(of, pl_event_of_match);
#else
# define pl_event_of_match
#endif


static struct platform_driver pl_event_driver = {
	.driver = {
		.name = DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table	= pl_event_of_match,
	},
	.probe		= pl_event_probe,
	.remove		= pl_event_remove,
};

static int __init pl_event_init(void)
{	
	printk("pl event init\n");

	return platform_driver_register(&pl_event_driver);
}


static void __exit pl_event_exit(void)
{
	platform_driver_unregister(&pl_event_driver);
	
	printk(KERN_ALERT "pl event exit.\n");
}

module_init(pl_event_init);
module_exit(pl_event_exit);
